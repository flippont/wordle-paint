<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Paint</title>
</head>

<body>
    <style>
        body {
            background-color: #ffc2c2;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            color: #333;
            padding: 0px;
            image-rendering: pixelated;
        }
        .container {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 30px;
            align-items: flex-start;
            width: 600px;
            min-height: 100vh;
            box-sizing: border-box;
            background-color: #FFF;
            padding: 40px 25px;
        }
        .left-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        .right-panel {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            width: 320px;
        }
        .title { 
            font-size: 20px; 
            margin-bottom: 15px; 
            letter-spacing: 2px; 
            font-weight: bold; 
        }
        .word-input {
            font-size: 18px;
            border: 2px solid #787c7f; 
            padding: 10px; 
            background: #f0f0f0;
            width: 100%;
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
        }
        .label {
            font-size: 18px;
            width: 100%;
            margin-top: 18px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            width: 200px;
            height: 240px;
            padding: 2px;
            background:#787c7f;
        }

        .pixel {
            background-color: #fff;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .colours {
            padding: 10px 20px 10px 20px;
            background: #eee;
            width: 100%;
            box-sizing: border-box;
        }

        .colour {
            width: 40px;
            height: 40px;
            margin: 5px 10px 5px 0;
            display: inline-block;
            box-sizing: border-box;
        }
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            width: 100%;
        }
        button {
            margin-top: 0;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #eee;
            border: none;
            font-family: 'Courier New', Courier, monospace;
        }
        #result {
            margin-top: 20px;
            font-size: 18px;
            width: 100%;
            word-break: break-word;
        }
        .presets-section {
            margin-top: 25px;
            width: 100%;
            height: fit-content;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .presets-section.collapsed .presets-title:not(:first-child),
        .presets-section.collapsed .presets-list,
        .presets-section.collapsed #moreLettersBtn {
            display: none !important;
        }
        .presets-toggle-btn {
            display: none;
            width: 100%;
            background: #eee;
            border: none;
            font-size: 16px;
            padding: 8px 0;
            margin-bottom: 8px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
        }
        .presets-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }
        .presets-list {
            display: flex;
            gap: 10px;
            flex-wrap: wrap; 
            justify-content: center; 
        }
        .preset-preview {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1px;
            background: #787c7f;
            padding: 2px;
            width: 45px;
            height: 45px;
            cursor: pointer;
            border: 2px solid #eee;
            transition: border 0.15s;
        }
        .preset-preview.selected {
            border: 2px solid #c8b653;
        }
        .preset-pixel {
            width: 100%;
            height: 100%;
            background: #fff;
        }
        .preset-label {
            text-align: center;
            font-size: 13px;
            margin-top: 2px;
            color: #555;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-inner {
            background: #fff;
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            width: 90vw;
            max-width: 600px;
        }
        .close-modal {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
        }
        @media (max-width: 600px) {
            body{ 
                background-color: #FFF;
            }
            .container {
                display: flex;
                flex-direction: column;
                width: 100vw;
                min-width: 0;
                padding: 10px 0;
                gap: 0;
            }
            .left-panel, .right-panel {
                width: 100vw;
                min-width: 0;
                box-sizing: border-box;
                align-items: center;
            }
            .right-panel {
                align-items: center;
                width: 100vw;
                padding: 0 10px;
            }
            .word-input, #result, .label, .colours {
                width: 100vw;
                max-width: 320px;
                min-width: 0;
            }
            #generateBtn {
                width: 320px;
            }
            .presets-toggle-btn {
                display: block;
            }
        }
    </style>
    <div class="container">
        <div class="left-panel">
            <div class="grid" id="canvas"></div>
            <!-- Presets Section -->
            <div class="presets-section collapsed" id="presetsSection">
                <button class="presets-toggle-btn" id="presetsToggleBtn">Show Presets ▼</button>
                <div class="presets-title">Presets:</div>
                <div class="presets-list" id="designPresetsList"></div>
                <div class="presets-title" style="margin-top:18px;">Letters:</div>
                <div class="presets-list" id="letterPresetsList"></div>
                <button id="moreLettersBtn" style="margin-top:10px; display:none;">More Letters...</button>
            </div>
        </div>
        <div class="right-panel">
            <h1 class="title">Wordle Paint</h1>
            <input class="word-input" id="title" type="text" maxlength="5" placeholder="Today's word">
            <p class="label">Select Colour:</p>
            <div class="colours" id="colours"></div>
            <div class="button-row">
                <button id="generateBtn">Generate</button>
                <button id="clearBtn">Clear</button>
                <button id="flipBtn">Flip</button>
            </div>
            <div id="result"></div>
        </div>
    </div>
    <!-- Modal for more letters -->
    <div id="lettersModal" class="modal">
        <div class="modal-inner">
            <button id="closeLettersModal" class="close-modal">&times;</button>
            <div class="presets-title" style="margin-bottom:12px;">All Letters</div>
            <div class="presets-list" id="modalLetterPresetsList"></div>
        </div>
    </div>
    <script>
        const grid = document.getElementById('canvas');
        const title = document.getElementById('title');
        let availableColours = ['#ffffff', '#c8b653', '#6ca965'] // available colours
        let currentSelectedColour = availableColours[2]; // Default colour
        window.currentPixels = Array(30).fill(0); // Initialize with white
        const PRESETS = [
            {
                name: "Tree",
                pattern: [
                    0,0,1,0,0,
                    0,0,2,0,0,
                    0,1,1,1,0,
                    0,2,2,2,0,
                    1,1,1,1,1,
                    2,2,2,2,2
                ]
            },
            {
                name: "Stairs",
                pattern: [
                    0,0,0,0,1,0,
                    0,0,1,1,0,0,
                    1,1,1,0,1,1,
                    1,1,1,1,1,1,
                    1,2,2,2,2,2
                ]
            }
        ];

        // Separate arrays for design and letter presets
        const DESIGN_PRESETS = PRESETS.slice();
        const LETTER_PRESETS = [];

        (function addAlphabetPresets() {
            const letters = {
                A: [
                    0,1,1,1,0,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,1,1,1,1,
                    1,0,0,0,1,
                    1,0,0,0,1
                ],
                B: [
                    1,1,1,1,0,
                    1,0,0,0,1,
                    1,1,1,1,0,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,1,1,1,0
                ],
                C: [
                    0,1,1,1,1,
                    1,0,0,0,0,
                    1,0,0,0,0,
                    1,0,0,0,0,
                    1,0,0,0,0,
                    0,1,1,1,1
                ],
                D: [
                    1,1,1,1,0,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,1,1,1,0
                ],
                E: [
                    1,1,1,1,1,
                    1,0,0,0,0,
                    1,1,1,1,0,
                    1,0,0,0,0,
                    1,0,0,0,0,
                    1,1,1,1,1
                ],
                F: [
                    1,1,1,1,1,
                    1,0,0,0,0,
                    1,1,1,1,0,
                    1,0,0,0,0,
                    1,0,0,0,0,
                    1,0,0,0,0
                ],
                G: [
                    0,1,1,1,1,
                    1,0,0,0,0,
                    1,0,0,1,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    0,1,1,1,1
                ],
                H: [
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,1,1,1,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1
                ],
                I: [
                    1,1,1,1,1,
                    0,0,1,0,0,
                    0,0,1,0,0,
                    0,0,1,0,0,
                    0,0,1,0,0,
                    1,1,1,1,1
                ],
                J: [
                    0,0,0,1,1,
                    0,0,0,0,1,
                    0,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    0,1,1,1,0
                ],
                K: [
                    1,0,0,0,1,
                    1,0,0,1,0,
                    1,0,1,0,0,
                    1,1,0,0,0,
                    1,0,1,0,0,
                    1,0,0,1,0
                ],
                L: [
                    1,0,0,0,0,
                    1,0,0,0,0,
                    1,0,0,0,0,
                    1,0,0,0,0,
                    1,0,0,0,0,
                    1,1,1,1,1
                ],
                M: [
                    1,0,0,0,1,
                    1,1,0,1,1,
                    1,0,1,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1
                ],
                N: [
                    1,0,0,0,1,
                    1,1,0,0,1,
                    1,0,1,0,1,
                    1,0,0,1,1,
                    1,0,0,0,1,
                    1,0,0,0,1
                ],
                O: [
                    0,1,1,1,0,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    0,1,1,1,0
                ],
                P: [
                    1,1,1,1,0,
                    1,0,0,0,1,
                    1,1,1,1,0,
                    1,0,0,0,0,
                    1,0,0,0,0,
                    1,0,0,0,0
                ],
                Q: [
                    0,1,1,1,0,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,1,0,1,
                    0,1,1,1,1
                ],
                R: [
                    1,1,1,1,0,
                    1,0,0,0,1,
                    1,1,1,1,0,
                    1,0,1,0,0,
                    1,0,0,1,0,
                    1,0,0,0,1
                ],
                S: [
                    0,1,1,1,1,
                    1,0,0,0,0,
                    0,1,1,1,0,
                    0,0,0,0,1,
                    1,0,0,0,1,
                    0,1,1,1,0
                ],
                T: [
                    1,1,1,1,1,
                    0,0,1,0,0,
                    0,0,1,0,0,
                    0,0,1,0,0,
                    0,0,1,0,0,
                    0,0,1,0,0
                ],
                U: [
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    0,1,1,1,0
                ],
                V: [
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    0,1,0,1,0,
                    0,0,1,0,0
                ],
                W: [
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,0,0,1,
                    1,0,1,0,1,
                    1,1,0,1,1,
                    1,0,0,0,1
                ],
                X: [
                    1,0,0,0,1,
                    0,1,0,1,0,
                    0,0,1,0,0,
                    0,0,1,0,0,
                    0,1,0,1,0,
                    1,0,0,0,1
                ],
                Y: [
                    1,0,0,0,1,
                    0,1,0,1,0,
                    0,0,1,0,0,
                    0,0,1,0,0,
                    0,0,1,0,0,
                    0,0,1,0,0
                ],
                Z: [
                    1,1,1,1,1,
                    0,0,0,1,0,
                    0,0,1,0,0,
                    0,1,0,0,0,
                    1,0,0,0,0,
                    1,1,1,1,1
                ]
            };
            for (const [letter, pattern] of Object.entries(letters)) {
                LETTER_PRESETS.push({
                    name: letter,
                    pattern: pattern.flat()
                });
            }
        })();

        // get current date in yyyymmdd format
        let date = new Date();
        let dateFormat = [];
        dateFormat.push(date.getFullYear().toString())
        dateFormat.push((date.getMonth() + 1).toString().padStart(2, '0'))
        dateFormat.push(date.getDate().toString().padStart(2, '0'));
        getWordle(dateFormat.join('-')).then(data => {
            if(data && data.solution) {
                title.value = data.solution;
            }
        });
        async function getWordle(date) {
            const response = await fetch(
                `https://www.nytimes.com/svc/wordle/v2/${date}.json`,
            );
            return await response.json();
        }

        let fiveLetterWords = [];

        // Fetch five-letter words from an online source
        async function fetchFiveLetterWords() {
            const response = await fetch('https://raw.githubusercontent.com/tabatkins/wordle-list/main/words');
            const text = await response.text();
            fiveLetterWords = text.split('\n').map(w => w.trim().toLowerCase()).filter(w => w.length === 5 && /^[a-z]+$/.test(w));
        }
        fetchFiveLetterWords();

        // 5x5 pixel grid
        for (let i = 0; i < 30; i++) {
            const pixel = document.createElement('div');
            pixel.classList.add('pixel');
            pixel.dataset.index = i;
            pixel.addEventListener('click', function () {
                const index = this.dataset.index;
                window.currentPixels[index] = availableColours.indexOf(currentSelectedColour);
                this.style.backgroundColor = currentSelectedColour;
            });
            grid.appendChild(pixel);
        }

        // Colour selection
        for(let i=0; i<availableColours.length; i++){
            const colourDiv = document.createElement('div');
            colourDiv.classList.add('colour')
            colourDiv.style.backgroundColor = availableColours[i];
            colourDiv.style.cursor = 'pointer';
            colourDiv.addEventListener('click', function(){
                currentSelectedColour = availableColours[i];
                updateBorders();
            });
            updateBorders();
            document.getElementById('colours').appendChild(colourDiv);
        }

        // Update borders to indicate selected color
        function updateBorders(){
            const colourDivs = document.getElementsByClassName('colour');
            for(let j=0; j<colourDivs.length; j++){
                colourDivs[j].style.border = (availableColours[j] == currentSelectedColour) ? '3px solid #787c7f' : 'none';
            }
        }

        // Generate button logic
        document.getElementById('generateBtn').addEventListener('click', async function() {
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = "Generating...";
            await ensureWordsLoaded();
            const pattern = [];
            for (let row = 0; row < 6; row++) {
                pattern.push(window.currentPixels.slice(row * 5, row * 5 + 5));
            }
            const targetWord = title.value.trim().toLowerCase();
            if (!/^[a-z]{5}$/.test(targetWord)) {
                resultDiv.innerHTML = "<b>Please enter a valid 5-letter word as the target.</b>";
                return;
            }
            if(targetWord && !fiveLetterWords.includes(targetWord)) {
                resultDiv.innerHTML = "<b>The target word is not in the five-letter word list.</b>";
                return;
            }
            // Find a possible solution (one word per row)
            const solution = findWordsForPatternWithTarget(pattern, fiveLetterWords, availableColours, targetWord);

            // Find all possible suggestions for each row
            const suggestions = getSuggestionsForPatternRows(pattern, fiveLetterWords, targetWord);

            let html = "";
            if (solution) {
                html += "<b>Words:</b> " + solution.join(', ').toUpperCase() + "<br><br>";
            } else {
                html += "<b>No solution found for this pattern and target word.</b><br><br>";
                // Show definite words section
                const definiteWords = findDefiniteWordsForPattern(pattern, fiveLetterWords, availableColours, 10);
                html += "<b>Definite Words (examples that work):</b><br>";
                if (definiteWords.length) {
                    html += definiteWords.map(w => w.toUpperCase()).join(', ');
                    if (definiteWords.length === 10) html += " ...";
                } else {
                    html += "<i>None found</i>";
                }
                html += "<br><br>";
            }
            html += "<b>Suggestions for each row:</b><br>";
            suggestions.forEach((words, idx) => {
                html += `<div><b>Row ${idx+1}:</b> ${words.length ? words.slice(0, 10).map(w=>w.toUpperCase()).join(', ') : '<i>None</i>'}${words.length > 10 ? ' ...' : ''}</div>`;
            });
            resultDiv.innerHTML = html;
        });

        async function ensureWordsLoaded() {
            if (!fiveLetterWords || fiveLetterWords.length === 0) {
                await fetchFiveLetterWords();
            }
        }

        function getWordlePattern(solution, guess) {
            let pattern = Array(5).fill(0);
            let solArr = solution.split('');
            let guessArr = guess.split('');
            let used = Array(5).fill(false);

            for (let i = 0; i < 5; i++) {
                if (guessArr[i] === solArr[i]) {
                    pattern[i] = 2;
                    used[i] = true;
                    solArr[i] = null;
                }
            }
            for (let i = 0; i < 5; i++) {
                if (pattern[i] === 1) continue;
                let idx = solArr.indexOf(guessArr[i]);
                if (idx !== -1 && !used[idx]) {
                    pattern[i] = 1;
                    solArr[idx] = null;
                }
            }
            return pattern;
        }

        // Cache for pattern lookups: { patternKey: [matchingWords] }
        const patternCache = {};

        // Optimized function: cache and only brute-force single non-green positions
        function findWordsForPatternWithTarget(pattern, wordList, availableColours, targetWord) {
            let guesses = [];
            for (let row = 0; row < 6; row++) {
                const gridPat = pattern[row];
                const patKey = gridPat.join('');
                // Use cache if available
                if (!patternCache[patKey]) {
                    // Count non-green positions
                    let nonGreenIdxs = [];
                    for (let i = 0; i < 5; i++) {
                        if (gridPat[i] !== 2) nonGreenIdxs.push(i);
                    }
                    let matches = [];
                    if (nonGreenIdxs.length === 1) {
                        // Only one non-green: try all possible letters in that position
                        const idx = nonGreenIdxs[0];
                        for (let ch = 97; ch <= 122; ch++) {
                            let guessArr = targetWord.split('');
                            guessArr[idx] = String.fromCharCode(ch);
                            let guess = guessArr.join('');
                            if (wordList.includes(guess)) {
                                let pat = getWordlePattern(targetWord, guess);
                                if (pat.join('') === patKey) {
                                    matches.push(guess);
                                }
                            }
                        }
                    } else {
                        // Fallback: brute-force all words
                        for (let guess of wordList) {
                            let pat = getWordlePattern(targetWord, guess);
                            if (pat.join('') === patKey) {
                                matches.push(guess);
                            }
                        }
                    }
                    patternCache[patKey] = matches;
                }
                // Use cached matches
                const matches = patternCache[patKey];
                if (matches.length > 0) {
                    guesses.push(matches[0]);
                } else {
                    return null;
                }
            }
            return guesses;
        }

        // Returns all possible words for each row that match the pattern for the target word
        function getSuggestionsForPatternRows(pattern, wordList, targetWord) {
            let suggestions = [];
            for (let row = 0; row < 6; row++) {
                let rowPattern = pattern[row];
                let matches = [];
                for (let guess of wordList) {
                    let pat = getWordlePattern(targetWord, guess).map(c => c);
                    if (pat.join('') === rowPattern.join('')) {
                        matches.push(guess);
                    }
                }
                suggestions.push(matches);
            }
            return suggestions;
        }

        document.getElementById('clearBtn').addEventListener('click', function() {
            window.currentPixels = Array(30).fill(0);
            const pixels = document.getElementsByClassName('pixel');
            for (let i = 0; i < pixels.length; i++) {
                pixels[i].style.backgroundColor = '#ffffff';
            }
        });

        // Flip Colours button logic
        document.getElementById('flipBtn').addEventListener('click', function() {
            for (let i = 0; i < window.currentPixels.length; i++) {
                if (window.currentPixels[i] === 1) {
                    window.currentPixels[i] = 2;
                } else if (window.currentPixels[i] === 2) {
                    window.currentPixels[i] = 1;
                }
            }
            const pixels = document.getElementsByClassName('pixel');
            for (let i = 0; i < pixels.length; i++) {
                pixels[i].style.backgroundColor = availableColours[window.currentPixels[i]];
            }
        });

        function renderPresets() {
            // Helper to render a list of presets into a container
            function renderPresetList(presets, containerId, onPresetClick) {
                const presetsList = document.getElementById(containerId);
                presetsList.innerHTML = '';
                presets.forEach((preset, idx) => {
                    const preview = document.createElement('div');
                    preview.className = 'preset-preview';
                    preview.title = preset.name;
                    for (let i = 0; i < 30; i++) {
                        const px = document.createElement('div');
                        px.className = 'preset-pixel';
                        px.style.background = availableColours[preset.pattern[i]];
                        preview.appendChild(px);
                    }
                    preview.addEventListener('click', function() {
                        if (onPresetClick) onPresetClick(preview, preset);
                    });
                    const label = document.createElement('div');
                    label.className = 'preset-label';
                    label.textContent = preset.name;
                    const container = document.createElement('div');
                    container.style.display = 'flex';
                    container.style.flexDirection = 'column';
                    container.style.alignItems = 'center';
                    container.appendChild(preview);
                    container.appendChild(label);
                    presetsList.appendChild(container);
                });
            }

            // Designs
            renderPresetList(DESIGN_PRESETS, 'designPresetsList', function(preview, preset) {
                window.currentPixels = preset.pattern.slice();
                const pixels = document.getElementsByClassName('pixel');
                for (let i = 0; i < pixels.length; i++) {
                    pixels[i].style.backgroundColor = availableColours[window.currentPixels[i]];
                }
                document.querySelectorAll('.preset-preview').forEach(el => el.classList.remove('selected'));
                preview.classList.add('selected');
            });

            // Letters: only first 4
            const letterPresetsList = document.getElementById('letterPresetsList');
            letterPresetsList.innerHTML = '';
            const firstFour = LETTER_PRESETS.slice(0, 3);
            renderPresetList(firstFour, 'letterPresetsList', function(preview, preset) {
                window.currentPixels = preset.pattern.slice();
                const pixels = document.getElementsByClassName('pixel');
                for (let i = 0; i < pixels.length; i++) {
                    pixels[i].style.backgroundColor = availableColours[window.currentPixels[i]];
                }
                document.querySelectorAll('.preset-preview').forEach(el => el.classList.remove('selected'));
                preview.classList.add('selected');
            });

            // Show/hide "More Letters..." button
            const moreBtn = document.getElementById('moreLettersBtn');
            if (LETTER_PRESETS.length > 3) {
                moreBtn.style.display = '';
            } else {
                moreBtn.style.display = 'none';
            }

            // Modal logic
            moreBtn.onclick = function() {
                document.getElementById('lettersModal').style.display = 'flex';
                // Render all letters in modal
                renderPresetList(LETTER_PRESETS, 'modalLetterPresetsList', function(preview, preset) {
                    window.currentPixels = preset.pattern.slice();
                    const pixels = document.getElementsByClassName('pixel');
                    for (let i = 0; i < pixels.length; i++) {
                        pixels[i].style.backgroundColor = availableColours[window.currentPixels[i]];
                    }
                    document.querySelectorAll('.preset-preview').forEach(el => el.classList.remove('selected'));
                    preview.classList.add('selected');
                    document.getElementById('lettersModal').style.display = 'none';
                });
            };
            document.getElementById('closeLettersModal').onclick = function() {
                document.getElementById('lettersModal').style.display = 'none';
            };
            // Optional: close modal on outside click
            document.getElementById('lettersModal').onclick = function(e) {
                if (e.target === this) this.style.display = 'none';
            };
        }
        renderPresets();

        // Find up to maxCount words that would produce a successful output for the current pattern
        function findDefiniteWordsForPattern(pattern, wordList, availableColours, maxCount = 10) {
            let definite = [];
            for (let word of wordList) {
                if (findWordsForPatternWithTarget(pattern, wordList, availableColours, word)) {
                    definite.push(word);
                    if (definite.length >= maxCount) break;
                }
            }
            return definite;
        }

        // Presets collapse/expand for mobile
        function updatePresetsCollapse() {
            const section = document.getElementById('presetsSection');
            const toggleBtn = document.getElementById('presetsToggleBtn');
            if (window.innerWidth <= 600) {
                section.classList.add('collapsed');
                toggleBtn.textContent = 'Show Presets ▼';
                toggleBtn.style.display = 'block';
            } else {
                section.classList.remove('collapsed');
                toggleBtn.style.display = 'none';
            }
        }
        document.getElementById('presetsToggleBtn').addEventListener('click', function() {
            const section = document.getElementById('presetsSection');
            if (section.classList.contains('collapsed')) {
                section.classList.remove('collapsed');
                this.textContent = 'Hide Presets ▲';
            } else {
                section.classList.add('collapsed');
                this.textContent = 'Show Presets ▼';
            }
        });
        window.addEventListener('resize', updatePresetsCollapse);
        window.addEventListener('DOMContentLoaded', updatePresetsCollapse);

        document.getElementById('title').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('generateBtn').click();
            }
        });
    </script>
</body>

</html>
